version: 3

tasks:
  default:
    desc: Welcome to the container bootstrapper.
    cmds:
      - task -l
    silent: true
    vars:
      OP_HOME:
        sh: "basename $PWD"

    preconditions:
      - sh: "which git"
        msg: "No git found"
      - sh: "which curl"
        msg: "No curl found"
      - sh: 'test -f /.dockerenv'
        msg: "It must run inside a container"

  ruby:install:
    desc: Installs Ruby
    env:
      USERNAME: runner
      VERSION: 3.4.5
      DISABLE_INSTALL_RUBY_MISE: 1
    cmds:
      - task: ruby:prepare:install
      - ./ruby/ruby-install.sh

  common:install:
    desc: Installs common dependencies
    env:
      USERNAME: runner
      VERSION: 3.4.5
      DISABLE_INSTALL_RUBY_MISE: 1
    cmds:
      - task: common:prepare:install
      - ./common-utils/install.sh

  ruby:prepare:install:
    desc: Installs ruby
    internal: true
    env:
      USERNAME: runner
      VERSION: 3.4.5
    cmds:
      - mkdir -p ruby
      - |-
        cat <<-'EOF' > ruby/ruby-install.sh
        #!/bin/sh
        set -e

        USERNAME="${USERNAME:-"${_REMOTE_USER:-"automatic"}"}"
        VERSION_MANAGER="${VERSIONMANAGER:-"mise"}"

        # Function to install dependencies needed for building Ruby
        install_dependencies() {
            apt-get update -y
            DEBIAN_FRONTEND=noninteractive apt-get -y install --no-install-recommends \
                git \
                curl \
                ca-certificates \
                libssl-dev \
                libreadline-dev \
                zlib1g-dev \
                autoconf \
                bison \
                build-essential \
                libyaml-dev \
                libncurses5-dev \
                libffi-dev \
                libgdbm-dev \
                libxml2-dev \
                rustc
        }

        # Function to add lines to shell initialization files
        add_to_shell_init() {
            _user="$1"
            _bash_line="$2"
            _zsh_line="${3:-$_bash_line}"  # Use bash_line as default if zsh_line not provided

            if [ "$_user" = "root" ]; then
                _home_dir="/root"
            else
                _home_dir="/home/$_user"
            fi

            echo "$_bash_line" >> "$_home_dir/.bashrc"

            if [ -f "$_home_dir/.zshrc" ]; then
                echo "$_zsh_line" >> "$_home_dir/.zshrc"
            fi
        }

        # Function to setup rbenv
        setup_rbenv() {
            _user="$1"
            _user_home="/home/$_user"

            # Clone rbenv and ruby-build
            git clone https://github.com/rbenv/rbenv.git /usr/local/share/rbenv
            git clone https://github.com/rbenv/ruby-build.git /usr/local/share/ruby-build

            # Setup plugins for root
            mkdir -p /root/.rbenv/plugins
            ln -s /usr/local/share/ruby-build /root/.rbenv/plugins/ruby-build

            # Setup for non-root user if needed
            if [ "$_user" != "root" ]; then
                mkdir -p "$_user_home/.rbenv/plugins"
                ln -s /usr/local/share/ruby-build "$_user_home/.rbenv/plugins/ruby-build"
                chown -R "$_user" "$_user_home/.rbenv/"
                chmod -R g+r+w "$_user_home/.rbenv"
            fi

            # shellcheck disable=SC2016
            add_to_shell_init "$_user" 'export PATH="/usr/local/share/rbenv/bin:$PATH"'
            # shellcheck disable=SC2016
            add_to_shell_init "$_user" 'eval "$(rbenv init -)"'
        }

        # Function to install Ruby with rbenv
        install_ruby_rbenv() {
            _user="$1"
            _version="$2"

            su "$_user" -c "/usr/local/share/rbenv/bin/rbenv install $_version"
            su "$_user" -c "/usr/local/share/rbenv/bin/rbenv global $_version"
        }

        # Function to setup mise
        setup_mise() {
            _user="$1"

            su "$_user" -c "curl https://mise.run | sh"

            # shellcheck disable=SC2016
            add_to_shell_init "$_user" 'eval "$(~/.local/bin/mise activate bash)"' 'eval "$(~/.local/bin/mise activate zsh)"'
        }

        # Function to install Ruby with mise
        install_ruby_mise() {
            _user="$1"
            _version="$2"

            if [ "$_user" = "root" ]; then
                _home_dir="/root"
            else
                _home_dir="/home/$_user"
            fi

            su "$_user" -c "$_home_dir/.local/bin/mise install ruby@$_version"
            su "$_user" -c "$_home_dir/.local/bin/mise use -g ruby@$_version"
            su "$_user" -c "$_home_dir/.local/bin/mise settings add idiomatic_version_file_enable_tools ruby"
        }

        install_dependencies

        # Setup version manager and install Ruby based on user choice
        if [ "$VERSION_MANAGER" = "rbenv" ]; then
            setup_rbenv "$USERNAME"
            install_ruby_rbenv "$USERNAME" "$VERSION"
        else
            setup_mise "$USERNAME"
            if [ -z "$DISABLE_INSTALL_RUBY_MISE" ]; then
              install_ruby_mise "$USERNAME" "$VERSION"
            fi
        fi

        rm -rf /var/lib/apt/lists/*
        EOF

      - |
        cat <<-'EOF' > ruby/activestorage-install.sh
        #!/bin/sh
        set -e
        VARIANTPROCESSOR="libvips"

        if [ "$VARIANTPROCESSOR" = "mini_magick" ]; then
          IMAGE_PROCESSOR="imagemagick"
        else
          IMAGE_PROCESSOR="libvips"
        fi

        export DEBIAN_FRONTEND=noninteractive

        apt-get update -qq && \
          apt-get install --no-install-recommends -y \
            $IMAGE_PROCESSOR
            # ffmpeg \
            # poppler-utils

        rm -rf /var/lib/apt/lists/*
        EOF
      - chmod +x ruby/*.sh

  common:prepare:install:
    desc: Installs common dependencies
    internal: true
    env:
      USERNAME: runner
      INSTALLZSH: "false"
      INSTALLOHMYZSH: "false"
      INSTALLOHMYZSHCONFIG: "false"
    cmds:
      - mkdir -p common-utils/scripts common-utils/bin
      - |
        cat <<-'EOF' > common-utils/main.sh
        #!/bin/bash
        #-------------------------------------------------------------------------------------------------------------------------
        # Copyright (c) Microsoft Corporation. All rights reserved.
        # Licensed under the MIT License. See https://github.com/devcontainers/features/blob/main/LICENSE for license information.
        #-------------------------------------------------------------------------------------------------------------------------
        #
        # Docs: https://github.com/devcontainers/features/tree/main/src/common-utils
        # Maintainer: The Dev Container spec maintainers

        set -e

        INSTALL_ZSH="${INSTALLZSH:-"true"}"
        CONFIGURE_ZSH_AS_DEFAULT_SHELL="${CONFIGUREZSHASDEFAULTSHELL:-"false"}"
        INSTALL_OH_MY_ZSH="${INSTALLOHMYZSH:-"true"}"
        INSTALL_OH_MY_ZSH_CONFIG="${INSTALLOHMYZSHCONFIG:-"true"}"
        UPGRADE_PACKAGES="${UPGRADEPACKAGES:-"true"}"
        USERNAME="${USERNAME:-"runner"}"
        USER_GID="${USERGID:-"1000"}"
        USER_UID="${USERUID:-"1000"}"
        ADD_NON_FREE_PACKAGES="${NONFREEPACKAGES:-"false"}"

        MARKER_FILE="/usr/local/etc/vscode-dev-containers/common"

        FEATURE_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

        # Debian / Ubuntu packages
        install_debian_packages() {
            # Ensure apt is in non-interactive to avoid prompts
            export DEBIAN_FRONTEND=noninteractive

            local package_list=""
            if [ "${PACKAGES_ALREADY_INSTALLED}" != "true" ]; then
                package_list="${package_list} \
                apt-utils \
                bash-completion \
                gnupg2 \
                iproute2 \
                procps \
                lsof \
                htop \
                net-tools \
                psmisc \
                curl \
                tree \
                wget \
                rsync \
                ca-certificates \
                unzip \
                bzip2 \
                xz-utils \
                zip \
                nano \
                vim-tiny \
                less \
                jq \
                lsb-release \
                apt-transport-https \
                libc6 \
                libgcc1 \
                libkrb5-3 \
                libgssapi-krb5-2 \
                libicu[0-9][0-9] \
                liblttng-ust[0-9] \
                libstdc++6 \
                zlib1g \
                locales \
                sudo \
                ncdu \
                manpages \
                libxml2 \
                libjemalloc2 \
                git \
                gpgv"

                # Disabled packages
                #
                # dialog \
                # man-db \
                # strace \
                # manpages-dev \
                # init-system-helpers \
                # openssh-client \
                # dirmngr \

                # Include libssl1.1 if available
                if [[ ! -z $(apt-cache --names-only search ^libssl1.1$) ]]; then
                    package_list="${package_list} libssl1.1"
                fi

                # Include libssl3 if available
                if [[ ! -z $(apt-cache --names-only search ^libssl3$) ]]; then
                    package_list="${package_list} libssl3"
                fi

                # Include appropriate version of libssl1.0.x if available
                local libssl_package=$(dpkg-query -f '${db:Status-Abbrev}\t${binary:Package}\n' -W 'libssl1\.0\.?' 2>&1 || echo '')
                if [ "$(echo "$libssl_package" | grep -o 'libssl1\.0\.[0-9]:' | uniq | sort | wc -l)" -eq 0 ]; then
                    if [[ ! -z $(apt-cache --names-only search ^libssl1.0.2$) ]]; then
                        # Debian 9
                        package_list="${package_list} libssl1.0.2"
                    elif [[ ! -z $(apt-cache --names-only search ^libssl1.0.0$) ]]; then
                        # Ubuntu 18.04
                        package_list="${package_list} libssl1.0.0"
                    fi
                fi

                # Include git if not already installed (may be more recent than distro version)
                if ! type git > /dev/null 2>&1; then
                    package_list="${package_list} git"
                fi
            fi

            # Needed for adding manpages-posix and manpages-posix-dev which are non-free packages in Debian
            if [ "${ADD_NON_FREE_PACKAGES}" = "true" ]; then
                if [[ ! -e "/etc/apt/sources.list" ]] && [[ -e "/etc/apt/sources.list.d/debian.sources" ]]; then
                    sed -i '/^URIs: http:\/\/deb.debian.org\/debian$/ { N; N; s/Components: main/Components: main non-free non-free-firmware/ }' /etc/apt/sources.list.d/debian.sources
                else
                    # Bring in variables from /etc/os-release like VERSION_CODENAME
                    sed -i -E "s/deb http:\/\/(deb|httpredir)\.debian\.org\/debian ${VERSION_CODENAME} main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME} main contrib non-free/" /etc/apt/sources.list
                    sed -i -E "s/deb-src http:\/\/(deb|httredir)\.debian\.org\/debian ${VERSION_CODENAME} main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME} main contrib non-free/" /etc/apt/sources.list
                    sed -i -E "s/deb http:\/\/(deb|httpredir)\.debian\.org\/debian ${VERSION_CODENAME}-updates main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME}-updates main contrib non-free/" /etc/apt/sources.list
                    sed -i -E "s/deb-src http:\/\/(deb|httpredir)\.debian\.org\/debian ${VERSION_CODENAME}-updates main/deb http:\/\/\1\.debian\.org\/debian ${VERSION_CODENAME}-updates main contrib non-free/" /etc/apt/sources.list
                    sed -i "s/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main contrib non-free/" /etc/apt/sources.list
                    sed -i "s/deb-src http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}\/updates main contrib non-free/" /etc/apt/sources.list
                    sed -i "s/deb http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main/deb http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main contrib non-free/" /etc/apt/sources.list
                    sed -i "s/deb-src http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main/deb http:\/\/deb\.debian\.org\/debian ${VERSION_CODENAME}-backports main contrib non-free/" /etc/apt/sources.list
                    # Handle bullseye location for security https://www.debian.org/releases/bullseye/amd64/release-notes/ch-information.en.html
                    sed -i "s/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main contrib non-free/" /etc/apt/sources.list
                    sed -i "s/deb-src http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main/deb http:\/\/security\.debian\.org\/debian-security ${VERSION_CODENAME}-security main contrib non-free/" /etc/apt/sources.list
                fi;
                echo "Running apt-get update..."
                package_list="${package_list} manpages-posix manpages-posix-dev"
            fi

            # Install the list of packages
            echo "Packages to verify are installed: ${package_list}"
            rm -rf /var/lib/apt/lists/*
            apt-get update -y
            apt-get -y install --no-install-recommends ${package_list} 2> >( grep -v 'debconf: delaying package configuration, since apt-utils is not installed' >&2 )

            # Install zsh (and recommended packages) if needed
            if [ "${INSTALL_ZSH}" = "true" ] && ! type zsh > /dev/null 2>&1; then
                apt-get install -y zsh
            fi

            # Get to latest versions of all packages
            if [ "${UPGRADE_PACKAGES}" = "true" ]; then
                apt-get -y upgrade --no-install-recommends
                apt-get autoremove -y
            fi

            # Ensure at least the en_US.UTF-8 UTF-8 locale is available = common need for both applications and things like the agnoster ZSH theme.
            if [ "${LOCALE_ALREADY_SET}" != "true" ] && ! grep -o -E '^\s*en_US.UTF-8\s+UTF-8' /etc/locale.gen > /dev/null; then
                echo "en_US.UTF-8 UTF-8" >> /etc/locale.gen
                locale-gen
                LOCALE_ALREADY_SET="true"
            fi

            PACKAGES_ALREADY_INSTALLED="true"

            # Clean up
            apt-get -y clean
            rm -rf /var/lib/apt/lists/*
        }

        # RedHat / RockyLinux / CentOS / Fedora packages
        install_redhat_packages() {
            local package_list=""
            local remove_epel="false"
            local install_cmd=microdnf
            if type microdnf > /dev/null 2>&1; then
               install_cmd=microdnf
            elif type tdnf > /dev/null 2>&1; then
               install_cmd=tdnf
            elif type dnf > /dev/null 2>&1; then
               install_cmd=dnf
            elif type yum > /dev/null 2>&1; then
               install_cmd=yum
            else
               echo "Unable to find 'tdnf', 'dnf', or 'yum' package manager. Exiting."
               exit 1
        fi

            if [ "${PACKAGES_ALREADY_INSTALLED}" != "true" ]; then
                package_list="${package_list} \
                    gawk \
                    bash-completion \
                    openssh-clients \
                    gnupg2 \
                    iproute \
                    procps \
                    lsof \
                    net-tools \
                    psmisc \
                    wget \
                    ca-certificates \
                    rsync \
                    unzip \
                    xz \
                    zip \
                    nano \
                    vim-minimal \
                    less \
                    jq \
                    openssl-libs \
                    krb5-libs \
                    libicu \
                    zlib \
                    sudo \
                    sed \
                    grep \
                    which \
                    man-db \
                    strace"

                # rockylinux:9 installs 'curl-minimal' which clashes with 'curl'
                # Install 'curl' for every OS except this rockylinux:9
                if [[ "${ID}" = "rocky" ]] && [[ "${VERSION}" != *"9."* ]]; then
                    package_list="${package_list} curl"
                fi

                # Install OpenSSL 1.0 compat if needed
                if ${install_cmd} -q list compat-openssl10 >/dev/null 2>&1; then
                    package_list="${package_list} compat-openssl10"
                fi

                # Install lsb_release if available
                if ${install_cmd} -q list redhat-lsb-core >/dev/null 2>&1; then
                    package_list="${package_list} redhat-lsb-core"
                fi

                # Install git if not already installed (may be more recent than distro version)
                if ! type git > /dev/null 2>&1; then
                    package_list="${package_list} git"
                fi

                # Install EPEL repository if needed (required to install 'jq' for CentOS)
                if ! ${install_cmd} -q list jq >/dev/null 2>&1; then
                    ${install_cmd} -y install epel-release
                    remove_epel="true"
                fi
            fi

            # Install zsh if needed
            if [ "${INSTALL_ZSH}" = "true" ] && ! type zsh > /dev/null 2>&1; then
                package_list="${package_list} zsh"
            fi

            if [ -n "${package_list}" ]; then
                ${install_cmd} -y install ${package_list}
            fi

            # Get to latest versions of all packages
            if [ "${UPGRADE_PACKAGES}" = "true" ]; then
                ${install_cmd} upgrade -y
            fi

            if [[ "${remove_epel}" = "true" ]]; then
                ${install_cmd} -y remove epel-release
            fi

            PACKAGES_ALREADY_INSTALLED="true"
        }

        # Alpine Linux packages
        install_alpine_packages() {
            apk update

            if [ "${PACKAGES_ALREADY_INSTALLED}" != "true" ]; then
                apk add --no-cache \
                    openssh-client \
                    bash-completion \
                    gnupg \
                    procps \
                    lsof \
                    htop \
                    net-tools \
                    psmisc \
                    curl \
                    wget \
                    rsync \
                    ca-certificates \
                    unzip \
                    xz \
                    zip \
                    nano \
                    vim \
                    less \
                    jq \
                    libgcc \
                    libstdc++ \
                    krb5-libs \
                    libintl \
                    lttng-ust \
                    tzdata \
                    userspace-rcu \
                    zlib \
                    sudo \
                    coreutils \
                    sed \
                    grep \
                    which \
                    ncdu \
                    shadow \
                    strace

                # # Include libssl1.1 if available (not available for 3.19 and newer)
                LIBSSL1_PKG=libssl1.1
                if [[ $(apk search --no-cache -a $LIBSSL1_PKG | grep $LIBSSL1_PKG) ]]; then
                    apk add --no-cache $LIBSSL1_PKG
                fi

                # Install man pages - package name varies between 3.12 and earlier versions
                if apk info man > /dev/null 2>&1; then
                    apk add --no-cache man man-pages
                else
                    apk add --no-cache mandoc man-pages
                fi

                # Install git if not already installed (may be more recent than distro version)
                if ! type git > /dev/null 2>&1; then
                    apk add --no-cache git
                fi
            fi

            # Install zsh if needed
            if [ "${INSTALL_ZSH}" = "true" ] && ! type zsh > /dev/null 2>&1; then
                apk add --no-cache zsh
            fi

            PACKAGES_ALREADY_INSTALLED="true"
        }

        # ******************
        # ** Main section **
        # ******************

        if [ "$(id -u)" -ne 0 ]; then
            echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
            exit 1
        fi

        # Load markers to see which steps have already run
        if [ -f "${MARKER_FILE}" ]; then
            echo "Marker file found:"
            cat "${MARKER_FILE}"
            source "${MARKER_FILE}"
        fi

        # Ensure that login shells get the correct path if the user updated the PATH using ENV.
        rm -f /etc/profile.d/00-restore-env.sh
        echo "export PATH=${PATH//$(sh -lc 'echo $PATH')/\$PATH}" > /etc/profile.d/00-restore-env.sh
        chmod +x /etc/profile.d/00-restore-env.sh

        # Bring in ID, ID_LIKE, VERSION_ID, VERSION_CODENAME
        . /etc/os-release
        # Get an adjusted ID independent of distro variants
        if [ "${ID}" = "debian" ] || [ "${ID_LIKE}" = "debian" ]; then
            ADJUSTED_ID="debian"
        elif [[ "${ID}" = "rhel" || "${ID}" = "fedora" || "${ID}" = "azurelinux" || "${ID}" = "mariner" || "${ID_LIKE}" = *"rhel"* || "${ID_LIKE}" = *"fedora"* || "${ID_LIKE}" = *"mariner"* ]]; then
            ADJUSTED_ID="rhel"
            VERSION_CODENAME="${ID}${VERSION_ID}"
        elif [ "${ID}" = "alpine" ]; then
            ADJUSTED_ID="alpine"
        else
            echo "Linux distro ${ID} not supported."
            exit 1
        fi

        if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
            # As of 1 July 2024, mirrorlist.centos.org no longer exists.
            # Update the repo files to reference vault.centos.org.
            sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
            sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
            sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
        fi

        if [ "${ADJUSTED_ID}" = "rhel" ] && [ "${VERSION_CODENAME-}" = "centos7" ]; then
            # As of 1 July 2024, mirrorlist.centos.org no longer exists.
            # Update the repo files to reference vault.centos.org.
            sed -i s/mirror.centos.org/vault.centos.org/g /etc/yum.repos.d/*.repo
            sed -i s/^#.*baseurl=http/baseurl=http/g /etc/yum.repos.d/*.repo
            sed -i s/^mirrorlist=http/#mirrorlist=http/g /etc/yum.repos.d/*.repo
        fi

        # Install packages for appropriate OS
        case "${ADJUSTED_ID}" in
            "debian")
                install_debian_packages
                ;;
            "rhel")
                install_redhat_packages
                ;;
            "alpine")
                install_alpine_packages
                ;;
        esac

        # If in automatic mode, determine if a user already exists, if not use vscode
        if [ "${USERNAME}" = "auto" ] || [ "${USERNAME}" = "automatic" ]; then
            if [ "${_REMOTE_USER}" != "root" ]; then
                USERNAME="${_REMOTE_USER}"
            else
                USERNAME=""
                POSSIBLE_USERS=("devcontainer" "vscode" "node" "codespace" "$(awk -v val=1000 -F ":" '$3==val{print $1}' /etc/passwd)")
                for CURRENT_USER in "${POSSIBLE_USERS[@]}"; do
                    if id -u ${CURRENT_USER} > /dev/null 2>&1; then
                        USERNAME=${CURRENT_USER}
                        break
                    fi
                done
                if [ "${USERNAME}" = "" ]; then
                    USERNAME=vscode
                fi
            fi
        elif [ "${USERNAME}" = "none" ]; then
            USERNAME=root
            USER_UID=0
            USER_GID=0
        fi
        # Create or update a non-root user to match UID/GID.
        group_name="${USERNAME}"
        if id -u ${USERNAME} > /dev/null 2>&1; then
            # User exists, update if needed
            if [ "${USER_GID}" != "automatic" ] && [ "$USER_GID" != "$(id -g $USERNAME)" ]; then
                group_name="$(id -gn $USERNAME)"
                groupmod --gid $USER_GID ${group_name}
                usermod --gid $USER_GID $USERNAME
            fi
            if [ "${USER_UID}" != "automatic" ] && [ "$USER_UID" != "$(id -u $USERNAME)" ]; then
                usermod --uid $USER_UID $USERNAME
            fi
        else
            # Create user
            if [ "${USER_GID}" = "automatic" ]; then
                groupadd $USERNAME
            else
                groupadd --gid $USER_GID $USERNAME
            fi
            if [ "${USER_UID}" = "automatic" ]; then
                useradd -s /bin/bash --gid $USERNAME -m $USERNAME
            else
                useradd -s /bin/bash --uid $USER_UID --gid $USERNAME -m $USERNAME
            fi
        fi

        # Add add sudo support for non-root user
        if [ "${USERNAME}" != "root" ] && [ "${EXISTING_NON_ROOT_USER}" != "${USERNAME}" ]; then
            echo $USERNAME ALL=\(root\) NOPASSWD:ALL > /etc/sudoers.d/$USERNAME
            chmod 0440 /etc/sudoers.d/$USERNAME
            EXISTING_NON_ROOT_USER="${USERNAME}"
        fi

        # *********************************
        # ** Shell customization section **
        # *********************************

        if [ "${USERNAME}" = "root" ]; then
            user_home="/root"
        # Check if user already has a home directory other than /home/${USERNAME}
        elif [ "/home/${USERNAME}" != $( getent passwd $USERNAME | cut -d: -f6 ) ]; then
            user_home=$( getent passwd $USERNAME | cut -d: -f6 )
        else
            user_home="/home/${USERNAME}"
            if [ ! -d "${user_home}" ]; then
                mkdir -p "${user_home}"
                chown ${USERNAME}:${group_name} "${user_home}"
            fi
        fi

        # Restore user .bashrc / .profile / .zshrc defaults from skeleton file if it doesn't exist or is empty
        possible_rc_files=( ".bashrc" ".profile" )
        [ "$INSTALL_OH_MY_ZSH_CONFIG" == "true" ] && possible_rc_files+=('.zshrc')
        [ "$INSTALL_ZSH" == "true" ] && possible_rc_files+=('.zprofile')
        for rc_file in "${possible_rc_files[@]}"; do
            if [ -f "/etc/skel/${rc_file}" ]; then
                if [ ! -e "${user_home}/${rc_file}" ] || [ ! -s "${user_home}/${rc_file}" ]; then
                    cp "/etc/skel/${rc_file}" "${user_home}/${rc_file}"
                    chown ${USERNAME}:${group_name} "${user_home}/${rc_file}"
                fi
            fi
        done

        # Add RC snippet and custom bash prompt
        if [ "${RC_SNIPPET_ALREADY_ADDED}" != "true" ]; then
            case "${ADJUSTED_ID}" in
                "debian")
                    global_rc_path="/etc/bash.bashrc"
                    ;;
                "rhel")
                    global_rc_path="/etc/bashrc"
                    ;;
                "alpine")
                    global_rc_path="/etc/bash/bashrc"
                    # /etc/bash/bashrc does not exist in alpine 3.14 & 3.15
                    mkdir -p /etc/bash
                    ;;
            esac
            cat "${FEATURE_DIR}/scripts/rc_snippet.sh" >> ${global_rc_path}
            cat "${FEATURE_DIR}/scripts/bash_theme_snippet.sh" >> "${user_home}/.bashrc"
            if [ "${USERNAME}" != "root" ]; then
                cat "${FEATURE_DIR}/scripts/bash_theme_snippet.sh" >> "/root/.bashrc"
                chown ${USERNAME}:${group_name} "${user_home}/.bashrc"
            fi
            RC_SNIPPET_ALREADY_ADDED="true"
        fi

        # Optionally configure zsh and Oh My Zsh!
        if [ "${INSTALL_ZSH}" = "true" ]; then
           if [ ! -f "${user_home}/.zprofile" ]; then
                touch "${user_home}/.zprofile"
                echo 'source $HOME/.profile' >> "${user_home}/.zprofile" # TODO: Reconsider adding '.profile' to '.zprofile'
                chown ${USERNAME}:${group_name} "${user_home}/.zprofile"
            fi

            if [ "${ZSH_ALREADY_INSTALLED}" != "true" ]; then
                if [ "${ADJUSTED_ID}" = "rhel" ]; then
                     global_rc_path="/etc/zshrc"
                else
                    global_rc_path="/etc/zsh/zshrc"
                fi
                cat "${FEATURE_DIR}/scripts/rc_snippet.sh" >> ${global_rc_path}
                ZSH_ALREADY_INSTALLED="true"
            fi

            if [ "${CONFIGURE_ZSH_AS_DEFAULT_SHELL}" == "true" ]; then
                # Fixing chsh always asking for a password on alpine linux
                # ref: https://askubuntu.com/questions/812420/chsh-always-asking-a-password-and-get-pam-authentication-failure.
                if [ ! -f "/etc/pam.d/chsh" ] || ! grep -Eq '^auth(.*)pam_rootok\.so$' /etc/pam.d/chsh; then
                    echo "auth sufficient pam_rootok.so" >> /etc/pam.d/chsh
                elif [[ -n "$(awk '/^auth(.*)pam_rootok\.so$/ && !/^auth[[:blank:]]+sufficient[[:blank:]]+pam_rootok\.so$/' /etc/pam.d/chsh)" ]]; then
                    awk '/^auth(.*)pam_rootok\.so$/ { $2 = "sufficient" } { print }' /etc/pam.d/chsh > /tmp/chsh.tmp && mv /tmp/chsh.tmp /etc/pam.d/chsh
                fi

                chsh --shell /bin/zsh ${USERNAME}
            fi

            # Adapted, simplified inline Oh My Zsh! install steps that adds, defaults to a codespaces theme.
            # See https://github.com/ohmyzsh/ohmyzsh/blob/master/tools/install.sh for official script.
            if [ "${INSTALL_OH_MY_ZSH}" = "true" ]; then
                user_rc_file="${user_home}/.zshrc"
                oh_my_install_dir="${user_home}/.oh-my-zsh"
                template_path="${oh_my_install_dir}/templates/zshrc.zsh-template"
                if [ ! -d "${oh_my_install_dir}" ]; then
                    umask g-w,o-w
                    mkdir -p ${oh_my_install_dir}
                    git clone --depth=1 \
                        -c core.eol=lf \
                        -c core.autocrlf=false \
                        -c fsck.zeroPaddedFilemode=ignore \
                        -c fetch.fsck.zeroPaddedFilemode=ignore \
                        -c receive.fsck.zeroPaddedFilemode=ignore \
                        "https://github.com/ohmyzsh/ohmyzsh" "${oh_my_install_dir}" 2>&1

                    # Shrink git while still enabling updates
                    cd "${oh_my_install_dir}"
                    git repack -a -d -f --depth=1 --window=1
                fi

                # Add Dev Containers theme
                mkdir -p ${oh_my_install_dir}/custom/themes
                cp -f "${FEATURE_DIR}/scripts/devcontainers.zsh-theme" "${oh_my_install_dir}/custom/themes/devcontainers.zsh-theme"
                ln -sf "${oh_my_install_dir}/custom/themes/devcontainers.zsh-theme" "${oh_my_install_dir}/custom/themes/codespaces.zsh-theme"

                # Add devcontainer .zshrc template
                if [ "$INSTALL_OH_MY_ZSH_CONFIG" = "true" ]; then
                    if ! [ -f "${template_path}" ] || ! grep -qF "$(head -n 1 "${template_path}")" "${user_rc_file}"; then
                        echo -e "$(cat "${template_path}")\nzstyle ':omz:update' mode disabled" > ${user_rc_file}
                    fi
                    sed -i -e 's/ZSH_THEME=.*/ZSH_THEME="devcontainers"/g' ${user_rc_file}
                fi

                # Copy to non-root user if one is specified
                if [ "${USERNAME}" != "root" ]; then
                    copy_to_user_files=("${oh_my_install_dir}")
                    [ -f "$user_rc_file" ] && copy_to_user_files+=("$user_rc_file")
                    cp -rf "${copy_to_user_files[@]}" /root
                    chown -R ${USERNAME}:${group_name} "${copy_to_user_files[@]}"
                fi
            fi
        fi

        # *********************************
        # ** Ensure config directory **
        # *********************************
        user_config_dir="${user_home}/.config"
        if [ ! -d "${user_config_dir}" ]; then
            mkdir -p "${user_config_dir}"
            chown ${USERNAME}:${group_name} "${user_config_dir}"
        fi

        # ****************************
        # ** Utilities and commands **
        # ****************************

        # code shim, it fallbacks to code-insiders if code is not available
        cp -f "${FEATURE_DIR}/bin/code" /usr/local/bin/
        chmod +rx /usr/local/bin/code

        # systemctl shim for Debian/Ubuntu - tells people to use 'service' if systemd is not running
        if [ "${ADJUSTED_ID}" = "debian" ]; then
            cp -fL "${FEATURE_DIR}/bin/systemctl" /usr/local/bin/systemctl
            chmod +rx /usr/local/bin/systemctl
        fi

        # Persist image metadata info, script if meta.env found in same directory
        if [ -f "/usr/local/etc/vscode-dev-containers/meta.env" ] || [ -f "/usr/local/etc/dev-containers/meta.env" ]; then
            cp -f "${FEATURE_DIR}/bin/devcontainer-info" /usr/local/bin/devcontainer-info
            chmod +rx /usr/local/bin/devcontainer-info
        fi

        # Write marker file
        if [ ! -d "/usr/local/etc/vscode-dev-containers" ]; then
            mkdir -p "$(dirname "${MARKER_FILE}")"
        fi
        echo -e "\
            PACKAGES_ALREADY_INSTALLED=${PACKAGES_ALREADY_INSTALLED}\n\
            LOCALE_ALREADY_SET=${LOCALE_ALREADY_SET}\n\
            EXISTING_NON_ROOT_USER=${EXISTING_NON_ROOT_USER}\n\
            RC_SNIPPET_ALREADY_ADDED=${RC_SNIPPET_ALREADY_ADDED}\n\
            ZSH_ALREADY_INSTALLED=${ZSH_ALREADY_INSTALLED}" > "${MARKER_FILE}"

        echo "Done!"

        EOF
      - |
        cat <<-'EOF' > common-utils/install.sh
        #!/bin/sh
        #-------------------------------------------------------------------------------------------------------------------------
        # Copyright (c) Microsoft Corporation. All rights reserved.
        # Licensed under the MIT License. See https://github.com/devcontainers/features/blob/main/LICENSE for license information.
        #-------------------------------------------------------------------------------------------------------------------------
        #
        # Docs: https://github.com/devcontainers/features/tree/main/src/common-utils
        # Maintainer: The Dev Container spec maintainers

        set -e

        INSTALL_ZSH="${INSTALLZSH:-"true"}"
        CONFIGURE_ZSH_AS_DEFAULT_SHELL="${CONFIGUREZSHASDEFAULTSHELL:-"false"}"
        INSTALL_OH_MY_ZSH="${INSTALLOHMYZSH:-"true"}"
        INSTALL_OH_MY_ZSH_CONFIG="${INSTALLOHMYZSHCONFIG:-"true"}"
        UPGRADE_PACKAGES="${UPGRADEPACKAGES:-"true"}"
        USERNAME="${USERNAME:-"runner"}"
        USER_UID="${UID:-"1000"}"
        USER_GID="${GID:-"1000"}"
        ADD_NON_FREE_PACKAGES="${NONFREEPACKAGES:-"false"}"

        MARKER_FILE="/usr/local/etc/vscode-dev-containers/common"

        if [ "$(id -u)" -ne 0 ]; then
            echo -e 'Script must be run as root. Use sudo, su, or add "USER root" to your Dockerfile before running this script.'
            exit 1
        fi

        # If we're using Alpine, install bash before executing
        . /etc/os-release
        if [ "${ID}" = "alpine" ]; then
            apk add --no-cache bash
        fi
        if [ "${ID}" = "azurelinux" ]; then
            tdnf install -y curl git
        fi
        exec /bin/bash "$(dirname $0)/main.sh" "$@"
        apt-get autoremove --assume-yes
        rm -rf /var/lib/apt/lists
        rm -fr /var/cache/apt

        exit $?

        EOF

      - |
        cat <<-'EOF' > common-utils/scripts/rc_snippet.sh
        if [ -z "${USER}" ]; then export USER=$(whoami); fi
        if [[ "${PATH}" != *"$HOME/.local/bin"* ]]; then export PATH="${PATH}:$HOME/.local/bin"; fi

        # Display optional first run image specific notice if configured and terminal is interactive
        if [ -t 1 ] && [[ "${TERM_PROGRAM}" = "vscode" || "${TERM_PROGRAM}" = "codespaces" ]] && [ ! -f "$HOME/.config/vscode-dev-containers/first-run-notice-already-displayed" ]; then
            if [ -f "/usr/local/etc/vscode-dev-containers/first-run-notice.txt" ]; then
                cat "/usr/local/etc/vscode-dev-containers/first-run-notice.txt"
            elif [ -f "/workspaces/.codespaces/shared/first-run-notice.txt" ]; then
                cat "/workspaces/.codespaces/shared/first-run-notice.txt"
            fi
            mkdir -p "$HOME/.config/vscode-dev-containers"
            # Mark first run notice as displayed after 10s to avoid problems with fast terminal refreshes hiding it
            ((sleep 10s; touch "$HOME/.config/vscode-dev-containers/first-run-notice-already-displayed") &)
        fi

        # Set the default git editor if not already set
        if [ -z "$(git config --get core.editor)" ] && [ -z "${GIT_EDITOR}" ]; then
            if  [ "${TERM_PROGRAM}" = "vscode" ]; then
                if [[ -n $(command -v code-insiders) &&  -z $(command -v code) ]]; then
                    export GIT_EDITOR="code-insiders --wait"
                else
                    export GIT_EDITOR="code --wait"
                fi
            fi
        fi

        EOF
      - |
        cat <<-'EOF' > common-utils/scripts/devcontainers.zsh-theme
        # Oh My Zsh! theme - partly inspired by https://github.com/ohmyzsh/ohmyzsh/blob/master/themes/robbyrussell.zsh-theme
        __zsh_prompt() {
            local prompt_username
            if [ ! -z "${GITHUB_USER}" ]; then
                prompt_username="@${GITHUB_USER}"
            else
                prompt_username="%n"
            fi
            PROMPT="%{$fg[green]%}${prompt_username} %(?:%{$reset_color%}➜ :%{$fg_bold[red]%}➜ )" # User/exit code arrow
            PROMPT+='%{$fg_bold[blue]%}%(5~|%-1~/…/%3~|%4~)%{$reset_color%} ' # cwd
            PROMPT+='`\
                if [ "$(git config --get devcontainers-theme.hide-status 2>/dev/null)" != 1 ] && [ "$(git config --get codespaces-theme.hide-status 2>/dev/null)" != 1 ]; then \
                    export BRANCH=$(git --no-optional-locks symbolic-ref --short HEAD 2>/dev/null || git --no-optional-locks rev-parse --short HEAD 2>/dev/null); \
                    if [ "${BRANCH}" != "" ]; then \
                        echo -n "%{$fg_bold[cyan]%}(%{$fg_bold[red]%}${BRANCH}" \
                        && if [ "$(git config --get devcontainers-theme.show-dirty 2>/dev/null)" = 1 ] && \
                            git --no-optional-locks ls-files --error-unmatch -m --directory --no-empty-directory -o --exclude-standard ":/*" > /dev/null 2>&1; then \
                                echo -n " %{$fg_bold[yellow]%}✗"; \
                        fi \
                        && echo -n "%{$fg_bold[cyan]%})%{$reset_color%} "; \
                    fi; \
                fi`'
            PROMPT+='%{$fg[white]%}$ %{$reset_color%}'
            unset -f __zsh_prompt
        }
        __zsh_prompt

        # Check if the terminal is xterm
        if [[ "$TERM" == "xterm" ]]; then
            # Function to set the terminal title to the current command
            preexec() {
                local cmd=${1}
                echo -ne "\033]0;${USER}@${HOSTNAME}: ${cmd}\007"
            }

            # Function to reset the terminal title to the shell type after the command is executed
            precmd() {
                echo -ne "\033]0;${USER}@${HOSTNAME}: ${SHELL}\007"
            }

            # Add the preexec and precmd functions to the corresponding hooks
            autoload -Uz add-zsh-hook
            add-zsh-hook preexec preexec
            add-zsh-hook precmd precmd
        fi

        EOF
      - |
        cat <<-'EOF' > common-utils/scripts/bash_theme_snippet.sh
        # bash theme - partly inspired by https://github.com/ohmyzsh/ohmyzsh/blob/master/themes/robbyrussell.zsh-theme
        __bash_prompt() {
            local userpart='`export XIT=$? \
                && [ ! -z "${GITHUB_USER:-}" ] && echo -n "\[\033[0;32m\]@${GITHUB_USER:-} " || echo -n "\[\033[0;32m\]\u " \
                && [ "$XIT" -ne "0" ] && echo -n "\[\033[1;31m\]➜" || echo -n "\[\033[0m\]➜"`'
            local gitbranch='`\
                if [ "$(git config --get devcontainers-theme.hide-status 2>/dev/null)" != 1 ] && [ "$(git config --get codespaces-theme.hide-status 2>/dev/null)" != 1 ]; then \
                    export BRANCH="$(git --no-optional-locks symbolic-ref --short HEAD 2>/dev/null || git --no-optional-locks rev-parse --short HEAD 2>/dev/null)"; \
                    if [ "${BRANCH:-}" != "" ]; then \
                        echo -n "\[\033[0;36m\](\[\033[1;31m\]${BRANCH:-}" \
                        && if [ "$(git config --get devcontainers-theme.show-dirty 2>/dev/null)" = 1 ] && \
                            git --no-optional-locks ls-files --error-unmatch -m --directory --no-empty-directory -o --exclude-standard ":/*" > /dev/null 2>&1; then \
                                echo -n " \[\033[1;33m\]✗"; \
                        fi \
                        && echo -n "\[\033[0;36m\]) "; \
                    fi; \
                fi`'
            local lightblue='\[\033[1;34m\]'
            local removecolor='\[\033[0m\]'
            PS1="${userpart} ${lightblue}\w ${gitbranch}${removecolor}\$ "
            unset -f __bash_prompt
        }
        __bash_prompt
        export PROMPT_DIRTRIM=4

        # Check if the terminal is xterm
        if [[ "$TERM" == "xterm" ]]; then
            # Function to set the terminal title to the current command
            preexec() {
                local cmd="${BASH_COMMAND}"
                echo -ne "\033]0;${USER}@${HOSTNAME}: ${cmd}\007"
            }

            # Function to reset the terminal title to the shell type after the command is executed
            precmd() {
                echo -ne "\033]0;${USER}@${HOSTNAME}: ${SHELL}\007"
            }

            # Trap DEBUG signal to call preexec before each command
            trap 'preexec' DEBUG

            # Append to PROMPT_COMMAND to call precmd before displaying the prompt
            PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND; }precmd"
        fi

        EOF
      - |
        cat <<-'EOF' > common-utils/bin/code
        #!/bin/sh

        get_in_path_except_current() {
            which -a "$1" | grep -A1 "$0" | grep -v "$0"
        }

        code="$(get_in_path_except_current code)"

        if [ -n "$code" ]; then
            exec "$code" "$@"
        elif [ "$(command -v code-insiders)" ]; then
            exec code-insiders "$@"
        else
            echo "code or code-insiders is not installed" >&2
            exit 127
        fi
        EOF
      - |
        cat <<-'EOF' > common-utils/bin/devcontainer-info
        #!/bin/sh

        # Load meta.env
        if [ -f "/usr/local/etc/vscode-dev-containers/meta.env" ]; then
            . /usr/local/etc/vscode-dev-containers/meta.env
        fi
        if [ -f "/usr/local/etc/dev-containers/meta.env" ]; then
            . /usr/local/etc/dev-containers/meta.env
        fi

        # Minimal output
        if [ "$1" = "version" ] || [ "$1" = "image-version" ]; then
            echo "${VERSION}"
            exit 0
        elif [ "$1" = "release" ]; then
            echo "${GIT_REPOSITORY_RELEASE}"
            exit 0
        elif [ "$1" = "content" ] || [ "$1" = "content-url" ] || [ "$1" = "contents" ] || [ "$1" = "contents-url" ]; then
            echo "${CONTENTS_URL}"
            exit 0
        fi

        #Full output
        echo
        echo "Development container image information"
        echo
        if [ ! -z "${VERSION}" ]; then echo "- Image version: ${VERSION}"; fi
        if [ ! -z "${DEFINITION_ID}" ]; then echo "- Definition ID: ${DEFINITION_ID}"; fi
        if [ ! -z "${VARIANT}" ]; then echo "- Variant: ${VARIANT}"; fi
        if [ ! -z "${GIT_REPOSITORY}" ]; then echo "- Source code repository: ${GIT_REPOSITORY}"; fi
        if [ ! -z "${GIT_REPOSITORY_RELEASE}" ]; then echo "- Source code release/branch: ${GIT_REPOSITORY_RELEASE}"; fi
        if [ ! -z "${GIT_REPOSITORY_REVISION}" ]; then echo "- Source code revision: ${GIT_REPOSITORY_REVISION}"; fi
        if [ ! -z "${BUILD_TIMESTAMP}" ]; then echo "- Timestamp: ${BUILD_TIMESTAMP}"; fi
        if [ ! -z "${CONTENTS_URL}" ]; then echo && echo "More info: ${CONTENTS_URL}"; fi
        echo

        EOF
      - |
        cat <<-'EOF' > common-utils/bin/systemctl
        #!/bin/sh
        set -e
        if [ -d "/run/systemd/system" ]; then
            exec /bin/systemctl "$@"
        else
            echo '\n"systemd" is not running in this container due to its overhead.\nUse the "service" command to start services instead. e.g.: \n\nservice --status-all'
        fi

        EOF
      - chmod +x common-utils/bin/* common-utils/scripts/*.sh common-utils/*.sh

  root:setup:
    desc: Inits the environment
    cmds:
      - task: "group:runtime:add"
      - task: "fs:tools"
      - task: "fs:tools:matchuid"
      - task: "acc:runner:add"
      - task: "acc:runner:sudoer"
      - task: "fs:folders"
      - task: "fs:bash-global"
      - task: "fs:files"
      - task: "ensure:perms"


  acc:runner:sudoer:
    desc: Elevates a user to sudoer
    vars:
      RUNTIME_GID: 4242
      RUN_USER:
        sh: "echo $RUN_USER"
    env:
      MHF_SKIP_PERMS: "yes"
      RUN_USER:
        sh: "echo $RUN_USER"
    cmds:
      - usermod -aG 0,{{.RUNTIME_GID}} {{.RUN_USER}}
      - echo "{{.RUN_USER}} ALL=(root) NOPASSWD:ALL" > /etc/sudoers.d/{{.RUN_USER}}
      - chmod 0440 /etc/sudoers.d/{{.RUN_USER}}
      - chmod -R g=u /etc/profile.d
      - chgrp -R 0 /etc/passwd /etc/group /etc/shadow
      - chmod 0640 /etc/shadow
      - chmod -R g=u /etc/passwd /etc/group /etc/shadow
    preconditions:
      - sh: "getent passwd {{.RUN_USER}}"
        msg: "No {{.RUN_USER}} found"

  acc:runner:match:
    internal: true
    desc: |-
      Adds the user reference to matchhostfsowner configuration
    env:
      RUN_UID:
        sh: "echo ${RUN_UID}"
      RUN_GID:
        sh: "echo ${RUN_GID}"
      RUN_USER:
        sh: "echo ${RUN_USER}"
      RUN_GROUP:
        sh: "echo ${RUN_GROUP}"
    cmds:
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/config.yml
        app_account: {{.RUN_USER}}
        app_group: {{.RUN_GROUP}}
        EOF
      - chmod 600 /etc/matchhostfsowner/*

  acc:runner:add:
    desc: |-
      Creates the user
    env:
      RUN_UID:
        sh: "echo ${RUN_UID}"
      RUN_GID:
        sh: "echo ${RUN_GID}"
      RUN_USER:
        sh: "echo ${RUN_USER}"
      RUN_GROUP:
        sh: "echo ${RUN_GROUP}"
    cmds:
      - groupadd -g {{.RUN_GID}} {{.RUN_GROUP}}
      - useradd -u {{.RUN_UID}} -g {{.RUN_GID}} -G {{.RUN_GROUP}},runtime -d /home/{{.RUN_USER}} --shell /bin/bash -m {{.RUN_USER}}
      - usermod -g {{.RUN_GID}} {{.RUN_USER}}
      - usermod -aG 4242 {{.RUN_USER}}
      - task: "acc:runner:match"

  group:runtime:add:
    desc: |-
      Adds the runtime group
    vars:
      RUNTIME_GID: 4242
      RUNTIME_GROUP: runtime
    cmds:
      - getent group {{.RUNTIME_GROUP}} || groupadd -g {{.RUNTIME_GID}} {{.RUNTIME_GROUP}}
      - groupmod -g {{.RUNTIME_GID}} {{.RUNTIME_GROUP}}

  fs:tools:
    desc: |-
      Installs tools
    cmds:
      - task: "fs:tools:starship"
      - task: "fs:tools:arkade"

  fs:tools:starship:
    desc: |-
      Installs the starship prompt
    cmds:
      - |-
        sh -c "$(curl -fsSL https://starship.rs/install.sh)" -- --yes && \
        chmod +x /usr/local/bin/starship

  fs:tools:bun:
    desc: |-
      Installs bun
    vars:
      BUN_VERSION: 1.2.22
    env:
      BUN_INSTALL: /usr/local/bun
    cmds:
      - |-
        BUN_INSTALL=/usr/local/bun
        PATH=/usr/local/bun/bin:$PATH
        curl -fsSL https://bun.sh/install | bash -s -- "bun-v{{.BUN_VERSION}}"
      - |-
        cat <<-'EOF' > /etc/profile.d/12-configure-bun.sh
        export BUN_INSTALL=/usr/local/bun
        export PATH=/usr/local/bun/bin:$PATH
        export BUN_VERSION=1.2.22
        EOF

  fs:tools:mise:
    desc: |-
      Installs mise
    env:
      RUN_UID:
        sh: "echo ${RUN_UID}"
      RUN_GID:
        sh: "echo ${RUN_GID}"
      RUN_USER:
        sh: "echo ${RUN_USER}"
      RUN_GROUP:
        sh: "echo ${RUN_GROUP}"
      MISE_INSTALL_PATH: /usr/local/bin/mise
    cmds:
      - |-
        curl https://mise.run | MISE_INSTALL_PATH=/usr/local/bin/mise sh
        chmod +x /usr/local/bin/*
      - |-
        cat <<-'EOF' > /etc/profile.d/13-activate-mise.sh
        eval "$(/usr/local/bin/mise activate bash)"
        EOF
      - |-
        cat <<-'EOF' >> /home/$RUN_USER/.bashrc
        eval "$(/usr/local/bin/mise activate bash)"
        EOF

  fs:tools:arkade:
    desc: |-
      Installs the arkade prompt
    cmds:
      - |-
        curl -SLfs https://get.arkade.dev | sh
        # echo 'eval "$(starship init bash)"' > /etc/profile.d/starship.sh

  fs:tools:chezmoi:
    internal: true
    desc: |-
      Installs the chezmoi dotfile et al manager
    cmds:
      - |-
        sh -c "$(curl -fsLS get.chezmoi.io)" -- -b /usr/local/bin && \
        chmod +x /usr/local/bin/chezmoi

  fs:tools:matchuid:
    desc: |-
      Installs matchhostfsowner cli
    cmds:
      - |-
        curl -LsS https://github.com/FooBarWidget/matchhostfsowner/releases/download/v1.0.1/matchhostfsowner-1.0.1-x86_64-linux.gz -o /sbin/matchhostfsowner.gz && \
        gunzip /sbin/matchhostfsowner.gz && \
        chown root: /sbin/matchhostfsowner && \
        chmod +x,+s /sbin/matchhostfsowner && \
        mkdir -p /etc/matchhostfsowner/hooks.d && \
        chown -R root: /etc/matchhostfsowner && \
        chmod -R 700 /etc/matchhostfsowner && \
        echo "# app_account: runner" >> /etc/matchhostfsowner/config.yml && \
        echo "# app_group: runtime" >> /etc/matchhostfsowner/config.yml && \
        chmod 600 /etc/matchhostfsowner/*

  fs:tools:matchuid:method2:
    desc: |-
      Installs matchhostfsowner cli - Method 2
    cmds:
      - |-
        curl -LsS https://github.com/FooBarWidget/matchhostfsowner/releases/download/v1.0.1/matchhostfsowner-1.0.1-x86_64-linux.gz -o /sbin/matchhostfsowner.gz && \
        gunzip /sbin/matchhostfsowner.gz && \
        chown root: /sbin/matchhostfsowner && \
        chmod +x /sbin/matchhostfsowner && \
        mkdir -p /etc/matchhostfsowner/hooks.d && \
        chown -R root: /etc/matchhostfsowner && \
        chmod -R 700 /etc/matchhostfsowner && \
        echo "# app_account: runner" >> /etc/matchhostfsowner/config.yml && \
        echo "# app_group: runtime" >> /etc/matchhostfsowner/config.yml && \
        chmod 600 /etc/matchhostfsowner/*


  fs:folders:
    desc: |-
      Inits the folders and sets the sticky bit to user 4242. Also removes the sticky bit from /tmp
    env:
      RUN_USER:
        sh: "echo ${RUN_USER}"
      RUN_UID:
        sh: "echo ${RUN_UID}"
      RUN_GID:
        sh: "echo ${RUN_GID}"
    cmds:
      - mkdir -p /bench /vols/storage /vols/data /projects
      - chgrp -R 4242 /bench /vols /projects
      - chmod -R g=u /bench /vols /projects
      - chmod g+s /bench /vols /projects
      - chmod -t /tmp
    preconditions:
      - sh: "which curl"
        msg: "No curl found"
      - sh: "which git"
        msg: "No git found"

  fs:bash-global:
    desc: |-
      Inits global bash config at /etc/profile.d
    cmds:
      - |-
        cat <<-'EOF' > /etc/profile.d/02-starship.sh
        eval "$(starship init bash)"
        EOF
      - |-
        cat <<-'EOF' > /etc/profile.d/01-ruby-env-path.sh
        export PATH=$GEM_HOME/bin:$BUNDLE_PATH/bin:/usr/local/bundle/bin:/usr/local/bundle/gems/bin:/usr/lib/fullstaq-ruby/versions/$RUBY_VERSION/bin:$PATH
        EOF
      - |-
        cat <<-'EOF' > /etc/profile.d/01-discover-jemalloc.sh
        # Enable jemalloc for reduced memory usage and latency.
        if [ -z "${LD_PRELOAD+x}" ]; then
            LD_PRELOAD=$(find /usr/lib -name libjemalloc.so.2 -print -quit)
            export LD_PRELOAD
        fi
        EOF
      - |-
        cat <<-'EOF' > /etc/profile.d/00-set-umask.sh
        umask 0002
        EOF
      - |-
        cat <<-'EOF' > /etc/profile.d/03-aliases.sh
        alias ll='ls -al --color'
        alias t='task'
        alias vim='vim.tiny'
        EOF
      - |-
        cat <<-'EOF' > /etc/profile.d/99-clean-env-path.sh
        echo "Cleaning PATH"
        echo "Before:Original: $PATH"
        # PATH=/usr/lib/fullstaq-ruby/versions/$RUBY_VERSION/bin:$GEM_HOME/bin:$BUNDLE_PATH/gems/bin:$PATH
        # echo "Before:Modified: $PATH"
        PATH=`printf %s "$PATH" | awk -v RS=: '{ if (!arr[$0]++) {printf("%s%s",!ln++?"":":",$0)}}'`
        export PATH
        echo "After:Cleaned: $PATH"
        EOF

  fs:mhfs-global:
    desc: |-
      Inits global matchhostfsowner config at /etc/matchhostfsowner/hooks.d
    cmds:
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/000-permit-tmp.sh
        #!/usr/bin/env bash
        echo "Configure tmp folder"
        set -e
        echo "Configure tmp folder"
        export TMPDIR=/tmp
        chmod -t /tmp
        EOF
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/00-get-vars.sh
        #!/usr/bin/env bash
        set -e
        echo "MHF_HOST_GID   :  ${MHF_HOST_GID}"
        echo "MHF_HOST_USER  :  ${MHF_HOST_USER}"
        echo "MHF_HOST_GROUP :  ${MHF_HOST_GROUP}"
        echo "MHF_HOST_HOME  :  ${MHF_HOST_HOME}"
        echo "MHF_HOST_UID   :  ${MHF_HOST_UID}"
        EOF
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/00-define-perms.sh-disabled
        #!/usr/bin/env bash
        ##set -e
        ##
        ##if [ -n "$GRANT_SUDO" ] && [ $GRANT_SUDO == "yes" ]; then
        ##  usermod -aG 0 ${MHF_HOST_USER}
        ##  echo "${MHF_HOST_USER} ALL=(root) NOPASSWD:ALL" > /etc/sudoers.d/${MHF_HOST_USER}
        ##  chmod 0440 /etc/sudoers.d/${MHF_HOST_USER}
        ##  chmod -R g=u /etc/profile.d
        ##  chgrp -R 0 /etc/passwd /etc/group /etc/shadow
        ##  chmod 0640 /etc/shadow
        ##  chmod -R g=u /etc/passwd /etc/group /etc/shadow
        ##  echo "sudo mode is set"
        ##fi
        ##
        ##unset GRANT_SUDO

        EOF
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/01-fix-perms.sh
        #!/usr/bin/env bash
        echo "Fixing permissions"
        set -e
        chgrp -R ${MHF_HOST_GID} ${MHF_HOST_HOME}
        chmod -R g=u ${MHF_HOST_HOME}
        # chown -Rv ${MHF_HOST_UID} /projects
        if [ -z "$MHF_SKIP_PERMS" ]; then
            if [ -n "$MHF_EXTRA_DIRS" ]; then
              for i in $MHF_EXTRA_DIRS; do
                if [ -d "$i" ]; then
                  # chgrp -R ${MHF_HOST_GID} $i
                  chown -R ${MHF_HOST_UID}:${MHF_HOST_GID} $i
                  # chmod -R g=u $i
                fi
              done
            fi
        fi
        EOF
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/02-open-perms.sh
        #!/usr/bin/env bash
        echo "Opening permissions"
        set -e
        if [ -z "$MHF_SKIP_PERMS" ]; then
            if [ -n "$MHF_EXTRA_PERMS" ]; then
              for i in $MHF_EXTRA_PERMS; do
                if [ -d "$i" ]; then
                  chmod -R 775 $i
                fi
              done
            fi
        fi
        EOF
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/03-create-extra-dirs.sh
        #!/usr/bin/env bash
        set -e
        if [ -z "$MHF_SKIP_PERMS" ]; then
          if [ -n "$MHF_CREATE_EXTRA_DIRS" ]; then
            for i in $MHF_CREATE_EXTRA_DIRS; do
              mkdir -p $i
              chmod -R 775 $i
            done
          fi
        fi
        EOF
      - |-
        cat <<-'EOF' > /etc/matchhostfsowner/hooks.d/05-assign-sticky-bit-on-dirs.sh
        #!/usr/bin/env bash
        echo "Assigning sticky bit on dirs"
        set -e
        if [ -z "$MHF_SKIP_PERMS" ]; then
          if [ -n "$MHF_STICKY_BIT_DIRS" ]; then
            for i in $MHF_STICKY_BIT_DIRS; do
              if [ -d "$i" ]; then
                mkdir -p $i
                chgrp -R 4242 $i
                chmod -R g=u $i
                chmod g+s $i
              fi
            done
          fi
        fi
        EOF
      - chmod +x /etc/matchhostfsowner/hooks.d/*.sh
      - chmod +x /etc/profile.d/*.sh

  fs:files:
    desc: |-
      Generates entrypoint
    cmds:
      - task: 'fs:files:entrypoint'
      - task: 'fs:files:fix-permissions'
      - task: 'fs:files:fix-dir-permissions'

  fs:files:entrypoint:
    desc: |-
      Generates entrypoint
    cmds:
      - mkdir -p /tmp/scripts
      - |-
        cat <<-'EOF' > /tmp/scripts/entrypoint.sh
        #!/usr/bin/env bash

        # DO NOT EDIT
        # Generated by bin/generate_files
        set -e
        echo "Running entrypoint.sh as: $(whoami)"

        cat <<ONE

        # INFO
        ## USER

        - Running as : $(whoami)
        - UID        : $(id -u)
        - GID        : $(id -g)
        - id         : $(id)

        ## FILESYSTEM
        - HOME       : $HOME
        - PWD        : $PWD

        ## ENV (configured)
        - RUN_UID    : $RUN_UID
        - RUN_GID    : $RUN_GID
        - RUN_USER   : $RUN_USER
        - RUN_GROUP  : $RUN_GROUP

        ONE

        export RUN_UID=$(id -u)
        export RUN_GID=$(id -g)
        export RUN_USER=$(whoami)
        export RUN_GROUP=$(id -gn)

        cat <<TWO
        ## ENV (current/active)
        - RUN_UID    : $RUN_UID
        - RUN_GID    : $RUN_GID
        - RUN_USER   : $RUN_USER
        - RUN_GROUP  : $RUN_GROUP

        TWO

        exec "$@"

        EOF
      - mv /tmp/scripts/entrypoint.sh /entrypoint.sh
      - chmod +x /entrypoint.sh
    status:
      - test -f /entrypoint.sh
    preconditions:
      - sh: "[ ! -f /entrypoint.sh ]"
        msg: "File entrypoint.sh already exists"

  fs:files:fix-permissions:
    desc: |-
      Generates assemble and fix-permissions
    cmds:
      - |-
        cat <<-'EOF' > /tmp/scripts/fix-permissions
        #!/usr/bin/env bash

        # Allow this script to fail without failing a build
        set +e

        TARGET_GROUP=${2:-4242}
        SYMLINK_OPT=${3:--L}

        EXCLUDE_DIRS="-not -path .git -prune "
        # Fix permissions on the given directory or file to allow group read/write of
        # regular files and execute of directories.

        [ $(id -u) -ne 0 ] && CHECK_OWNER=" -uid $(id -u)"

        # If argument does not exist, script will still exit with 0,
        # but at least we'll see something went wrong in the log
        if ! [ -e "$1" ] ; then
        echo "ERROR: File or directory $1 does not exist." >&2
        # We still want to end successfully
          exit 0
        fi

        echo "find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} \! -gid ${TARGET_GROUP} -exec sudo chgrp ${TARGET_GROUP} {} +"
        find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} \! -gid ${TARGET_GROUP} -exec sudo chgrp ${TARGET_GROUP} {} +
        find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} \! -perm -g+rw -exec sudo chmod g+rw {} +
        find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} -perm /u+x -a \! -perm /g+x -exec sudo chmod g+x {} +
        find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} -type d \! -perm /g+x -exec sudo chmod g+x {} +
        find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} -type d -perm -g=u -exec sudo chmod g=u {} +
        find $SYMLINK_OPT "$1" ${CHECK_OWNER} ${EXCLUDE_DIRS} -type f -perm -g=u -exec sudo chmod g=u {} +

          # Always end successfully
        exit 0
        EOF
      - mv /tmp/scripts/fix-permissions /usr/local/bin/fix-permissions
      - chmod +x /usr/local/bin/fix-permissions
    status:
      - test -f /usr/local/bin/fix-permissions
    preconditions:
      - sh: "[ ! -f /usr/local/bin/fix-permissions ]"
        msg: "File /usr/local/bin/fix-permissions already exists"

  fs:files:fix-dir-permissions:
    desc: |-
      Generates assemble and fix-permissions
    cmds:
      - mkdir -p /tmp/scripts
      - |-
        cat <<-'EOF' > /tmp/scripts/fix-dir-permissions
        #!/usr/bin/env bash
        # set permissions on a directory
        # after any installation, if a directory needs to be (human) user-writable,
        # run this script on it.
        # It will make everything in the directory owned by the group ${NB_GID}
        # and writable by that group.
        # Deployments that want to set a specific user id can preserve permissions
        # by adding the `--group-add users` line to `docker run`.

        # uses find to avoid touching files that already have the right permissions,
        # which would cause massive image explosion

        # right permissions are:
        # group=${RUN_AS_GID:-$RUN_GID}
        # AND permissions include group rwX (directory-execute)
        # AND directories have setuid,setgid bits set

        set -e
        run_group=${RUNTIME_GROUP:-runtime}
        run_gid=${RUNTIME_GID:-4242}
        for d in "$@"; do
            find -L "${d}" \
                ! \( \
                    -group $run_group \
                    -a -perm -g+rwX \
                \) \
                -exec chgrp $run_gid -- {} \+ \
                -exec chmod g+rwX -- {} \+
            # setuid, setgid *on directories only*
            find -L "${d}" \
                \( \
                    -type d \
                    -a ! -perm -6000 \
                \) \
                -exec chmod +6000 -- {} \+
        done


        EOF
      - mv /tmp/scripts/fix-dir-permissions /usr/local/bin/fix-dir-permissions
      - chmod +x /usr/local/bin/fix-dir-permissions
    status:
      - test -f /usr/local/bin/fix-dir-permissions
    preconditions:
      - sh: "[ ! -f /usr/local/bin/fix-dir-permissions ]"
        msg: "File /usr/local/bin/fix-dir-permissions already exists"

  ensure:perms:
    desc: Ensures permissions in folders
    env:
      RUN_UID:
        sh: "echo ${RUN_UID}"
      RUN_GID:
        sh: "echo ${RUN_GID}"
    cmds:
      - chgrp -R 4242 /bench /vols /projects
      - chown -R runner:runtime /projects /bench /vols
      - chmod -R g=u /bench /vols /projects
      - chmod g+s /bench /vols /projects

  history:setup:
    desc: sets up history
    env:
      RUN_UID:
        sh: "echo ${RUN_UID:-1000}"
      RUN_GID:
        sh: "echo ${RUN_GID:-1000}"
      RUN_USER:
        sh: "echo ${RUN_USER:-runner}"
    cmds:
      - mkdir -p /usr/local/hist
      - touch /usr/local/hist/.bash_history
      - chown -R $RUN_USER:$RUN_USER /usr/local/hist
      - chmod 700 /usr/local/hist/.bash_history
      - |-
        cat <<-'EOF' >> /etc/bash.bashrc

        export HISTFILE=/usr/local/hist/.bash_history

        export HISTSIZE=10000                  # Number of commands in memory
        export HISTFILESIZE=20000              # Number of commands in history file
        export HISTCONTROL=ignoredups:erasedups # Avoid duplicate entries
        shopt -s histappend                    # Append to history, don't overwrite
        export HISTTIMEFORMAT="%F %T "
        export HISTIGNORE="ls:pwd:exit:history"
        shopt -s cmdhist
        shopt -s cdspell

        EOF

      - |-
        cat <<-'EOF' >> /home/$RUN_USER/.bashrc

        export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

        EOF




  apt:no-docs:
    desc: |-
      Removes docs from apt
    cmds:
      - mkdir -p /etc/dpkg/dpkg.cfg.d
      - |-
        cat <<-'EOF' > /etc/dpkg/dpkg.cfg.d/01_nodoc
        path-exclude=/usr/share/doc/*
        path-exclude=/usr/share/man/*
        path-exclude=/usr/share/groff/*
        path-exclude=/usr/share/info/*
        path-exclude=/usr/share/lintian/*
        EOF
